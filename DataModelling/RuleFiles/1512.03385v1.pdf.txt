We present a residual learning framework to ease the training of networks that are substantially deeper than those used previously.
0.57 (We; present; a residual learning framework to ease the training of networks)
0.48 (networks; are; substantially deeper than those)
0.10 (those; used; T:previously)

We explicitly reformulate the layers as learning residual functions with reference to the layer inputs, instead of learning unreferenced functions.
0.57 (We; explicitly reformulate; the layers as learning residual functions with reference to the layer inputs, instead of learning unreferenced functions)

We provide comprehensive empirical evidence showing that these residual networks are easier to optimize, and can gain accuracy from considerably increased depth.
0.33 (We; provide; comprehensive empirical evidence showing that these residual networks are easier to optimize)
0.75 (comprehensive empirical evidence; showing; that these residual networks are easier to optimize)
0.74 Context(comprehensive empirical evidence showing):(these residual networks; are; easier to optimize)
0.41 (We; can gain; accuracy; from considerably increased depth)

On the ImageNet dataset we evaluate residual nets with a depth of up to 152 layers—8× deeper than VGG nets [41] but still having lower complexity.
0.64 (we; evaluate; residual nets; L:On the ImageNet dataset)

We also present analysis on CIFAR-10 with 100 and 1000 layers.
0.46 (We; present; analysis; T:on CIFAR-10)

Solely due to our extremely deep representations, we obtain a 28% relative improvement on the COCO object detection dataset.
0.61 (we; obtain; a 28% relative improvement on the COCO object detection dataset)

Deep residual nets are foundations of our submissions to ILSVRC & COCO 2015 competitions1, where we also won the 1st places on the tasks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation.
0.91 (Deep residual nets; are; foundations of our submissions to ILSVRC & COCO 2015 competitions1)
0.61 (we; also won; the 1st places on the tasks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation)

Unexpectedly, such degradation is not caused by overﬁtting, and adding more layers to a suitably deep model leads to higher training error, as reported in [11, 42] and thoroughly veriﬁed by our experiments.
0.90 (such degradation; is not caused; by overﬁtting)
0.94 (adding more layers to a suitably deep model; leads; to higher training error)

But experiments show that our current solvers on hand are unable to ﬁnd solutions that 01234560 1020iter.
0.73 (our current solvers on hand; to ﬁnd; solutions)
0.73 (experiments; show; that our current solvers on hand are unable to ﬁnd solutions)
0.64 Context(experiments show):(our current solvers on hand; are; unable to ﬁnd solutions)

This strong evidence shows that the residual learning principle is generic, and we expect that it is applicable in other vision and non-vision problems.
0.80 (This strong evidence; shows; that the residual learning principle is generic)
0.81 Context(This strong evidence shows):(the residual learning principle; is; generic)
0.17 (we; expect; that it is applicable in other vision and non-vision problems)
0.47 Context(we expect):(it; is; applicable in other vision and non-vision problems)

Concurrent with our work, “highway networks” [42, 43] present shortcut connections with gating functions [15].

These gates are data-dependent and have parameters, in contrast to our identity shortcuts that are parameter-free.
0.90 (These gates; are; data-dependent)
0.81 (These gates; have; parameters, in contrast to our identity shortcuts)
0.62 (our identity shortcuts; are; parameter-free)

On the contrary, our formulation always learns residual functions; our identity shortcuts are never closed, and all information is always passed through, with additional residual functions to be learned.
0.92 (all information; is passed; through; with additional residual functions; T:always)
0.75 (additional residual functions; to be learned; )
0.31 (our identity shortcuts; are never closed; )
0.68 Context(our identity shortcuts are never closed):(our formulation; learns; residual functions; T:always)

 In this paper, we address the degradation problem by introducing a deep residual Instead of hoping each few stacked layers directly ﬁt a desired underlying mapping, we explicitly let these layers ﬁt a residual mapping.
0.53 (we; address; the degradation problem; L:In this paper)
0.18 Context(we address):(we; address the degradation problem by introducing; a deep residual)
0.26 Context(we address):(we; address the degradation problem hoping; each few stacked layers directly ﬁt a desired underlying mapping, we explicitly let these layers ﬁt a residual mapping)
0.39 Context(we address hoping):(we; explicitly let; these layers ﬁt a residual mapping)
0.90 Context(we address hoping we explicitly let):(each few stacked layers; directly ﬁt; a desired underlying mapping)

Formally, denoting the desired underlying mapping as H(x), we let the stacked nonlinear layers ﬁt another mapping of F(x) := H(x)− x.
0.63 (we; let; the stacked nonlinear layers ﬁt another mapping of F(x) := H(x)
0.96 Context(we let):(the stacked nonlinear layers; ﬁt; another mapping of F(x) := H(x)

We hypothesize that it is easier to optimize the residual mapping than to optimize the original, unreferenced mapping.
0.12 (We; hypothesize; that it is easier to optimize the residual mapping)

In our case, the shortcut connections simply perform identity mapping, and their outputs are added to the outputs of the stacked layers (Fig.
0.91 (the shortcut connections; simply perform; identity mapping; L:In our case)
0.64 (their outputs; are added; to the outputs of the stacked layers (Fig)

We present comprehensive experiments on ImageNet [36] to show the degradation problem and evaluate our method.
0.41 (We; to show; the degradation problem)
0.20 (We; to evaluate; our method)

We show that: 1) Our extremely deep residual nets are easy to optimize, but the counterpart “plain” nets (that simply stack layers) exhibit higher training error when the depth increases; 2) Our deep residual nets can easily enjoy accuracy gains from greatly increased depth, producing results substantially better than previous networks.
0.22 (We; show; that: 1) Our extremely deep residual nets are easy to optimize, but the counterpart "plain" nets (that simply stack layers) exhibit higher training error)
0.40 Context(We show):(Our extremely deep residual nets; are; easy to optimize)
0.92 (the counterpart "plain" nets; exhibit; higher training error)
0.68 (Our deep residual nets; can easily enjoy; accuracy gains from greatly increased depth)

Similar phenomena are also shown on the CIFAR-10 set [20], suggesting that the optimization difﬁculties and the effects of our method are not just akin to a particular dataset.
0.70 (Similar phenomena; are shown; L:on the CIFAR-10 set; suggesting that the optimization difﬁculties and the effects of our method are not just akin to a particular dataset)

We present successfully trained models on this dataset with over 100 layers, and explore models with over 1000 layers.
0.45 (We; present successfully trained; models on this dataset; with over 100 layers)
0.41 (We; explore; models with over 1000 layers)

On the ImageNet classiﬁcation dataset [36], we obtain excellent results by extremely deep residual nets.
0.64 (we; obtain; excellent results; L:On the ImageNet classiﬁcation dataset)

Our 152layer residual net is the deepest network ever presented on ImageNet, while still having lower complexity than VGG nets [41].
0.77 (Our 152layer residual net; is; the deepest network ever presented on ImageNet)
0.95 (the deepest network; presented; L:on ImageNet; T:ever)

Our ensemble has 3.57% top-5 error on the identityweight layerweight layerrelureluF(x)(cid:1)+(cid:1)xxF(x)xway networks have not demonstrated accuracy gains with extremely increased depth (e.g., over 100 layers).
0.82 (Our ensemble; has; 3.57% top-5 error on the identityweight layerweight layerrelureluF)
0.95 (xxF(x)x way networks; have not demonstrated; accuracy gains with extremely increased depth)

So rather than expect stacked layers to approximate H(x), we explicitly let these layers approximate a residual function F(x) := H(x) − x.
0.39 (we; explicitly let; these layers approximate a residual function)
0.93 Context(we explicitly let):(these layers; approximate; a residual function F(x) := H(x) −)

As we discussed in the introduction, if the added layers can be constructed as identity mappings, a deeper model should have training error no greater than its shallower counterpart.
0.45 (we; discussed; L:in the introduction)
0.91 (the added layers; can be constructed; as identity mappings)
0.85 (a deeper model; should have; training error no greater than its shallower counterpart)

In real cases, it is unlikely that identity mappings are optimal, but our reformulation may help to precondition the problem.
0.58 (our reformulation; may help; to precondition the problem)
0.58 Context(our reformulation may help):(our reformulation; may help to precondition; the problem)

We show by experiments (Fig.
0.24 (We; show; )

Identity Mapping by Shortcuts We adopt residual learning to every few stacked layers.
0.45 (We; adopt; residual learning; to every few stacked layers)

Formally, in this paper we consider a building block deﬁned as: y = F(x,{Wi}) + x.
0.69 (we; consider; a building block deﬁned as: y = F(x,{Wi}) +; L:in this paper)
0.94 Context(we consider):(a building block; deﬁned; as: y = F(x,{Wi}) +)

We adopt the second nonlinearity after the addition (i.e., σ(y), see Fig.

This is not only attractive in practice but also important in our comparisons between plain and residual networks.
0.35 (This; is not; only attractive in practice but also important in our comparisons between plain and residual networks)

We can fairly compare plain/residual networks that simultaneously have the same number of parameters, depth, width, and computational cost (except for the negligible element-wise addition).
0.33 (We; can fairly compare; plain/residual networks that simultaneously have the same number of parameters, depth, width, and computational cost (except for the negligible element-wise addition))
0.96 (plain/residual networks; have; the same number of parameters, depth, width, and computational cost (except for the negligible element-wise addition; T:simultaneously)

If this is not the case (e.g., when changing the input/output channels), we can perform a linear projection Ws by the shortcut connections to match the dimensions: y = F(x,{Wi}) + Wsx.
0.38 (this; is not; the case)
0.53 (we; can perform; a linear projection; to match the dimensions; T:when changing the input/output channels)
0.29 Context(we can perform):(we; can perform a linear projection to match; the dimensions)

We can also use a square matrix Ws in Eqn.(1).
0.50 (We; can also use; a square matrix; L:in Eqn)

But we will show by experiments that the identity mapping is sufﬁcient for addressing the degradation problem and is economical, and thus Ws is only used when matching dimensions.
0.27 (we; will show; that the identity mapping is sufﬁcient for addressing the degradation problem and is economical, and thus Ws is only used)
0.91 Context(we will show):(the identity mapping; is; sufﬁcient for addressing the degradation problem)
0.80 (the identity mapping; is; economical)
0.86 (Ws; is only used; T:when matching dimensions)

But if F has only a single layer, Eqn.(1) is similar to a linear layer: y = W1x + x, for which we have not observed advantages.
0.89 (F; has; only a single layer)
0.41 (1; is; similar to a linear layer)
0.45 (we; have not observed; advantages)

We also note that although the above notations are about fully-connected layers for simplicity, they are applicable to convolutional layers.
0.91 (the above notations; are; about fully-connected layers for simplicity)
0.15 (We; note; that although the above notations are about fully-connected layers for simplicity, they are applicable to convolutional layers)
0.55 Context(We note):(they; are; applicable to convolutional layers)

Network Architectures We have tested various plain/residual nets, and have observed consistent phenomena.
0.45 (We; have tested; various plain/residual nets)
0.41 (We; have observed; consistent phenomena)

To provide instances for discussion, we describe two models for ImageNet as follows.
0.50 (we; describe; two models for ImageNet)

Our plain baselines (Fig.

We perform downsampling directly by convolutional layers that have a stride of 2.
0.89 (convolutional layers; have; a stride of 2)
0.40 (We; perform; downsampling directly by convolutional layers)
0.40 Context(We perform):(We; perform downsampling directly; by convolutional layers)

It is worth noticing that our model has fewer ﬁlters and lower complexity than VGG nets [41] (Fig.

Our 34layer baseline has 3.6 billion FLOPs (multiply-adds), which is only 18% of VGG-19 (19.6 billion FLOPs).
0.83 (Our 34layer baseline; has; 3.6 billion FLOPs (multiply-adds), which is only 18% of VGG-19 (19.6 billion FLOPs))
0.93 (3.6 billion FLOPs; is; only 18% of VGG-19)

Based on the above plain network, we insert shortcut connections (Fig.
0.45 (we; insert; shortcut connections (Fig)

3), we consider two options: (A) The shortcut still performs identity mapping, with extra zero entries padded for increasing dimensions.
0.57 (we; consider; two options: (A) The shortcut still performs identity mapping, with extra zero entries padded for increasing dimensions)
0.93 (The shortcut; performs; identity mapping; T:still)

Implementation Our implementation for ImageNet follows the practice in [21, 41].
0.76 (Implementation Our implementation for ImageNet; follows; the practice in [21, 41)

We adopt batch normalization (BN) [16] right after each convolution and before activation, following [16].
0.45 (We; adopt; batch normalization; T:right after each convolution and before activation)

We initialize the weights as in [13] and train all plain/residual nets from scratch.
0.45 (We; initialize; the weights)
0.41 (We; train; all plain/residual nets; from scratch)

We use SGD with a mini-batch size of 256.
0.50 (We; use; SGD)

We use a weight decay of 0.0001 and a momentum of 0.9.
0.57 (We; use; a weight decay of 0.0001 and a momentum of 0.9)

We do not use dropout [14], following the practice in [16].
0.39 (We; do not use; dropout)
0.29 Context(We do not use):(We; do not use dropout following; the practice; T:in [16)

In testing, for comparison studies we adopt the standard 10-crop testing [21].
0.60 (we; adopt; the standard 10-crop testing; L:In testing)

For best results, we adopt the fullyconvolutional form as in [41, 13], and average the scores at multiple scales (images are resized such that the shorter side is in {224, 256, 384, 480, 640}).
0.45 (we; adopt; the fullyconvolutional form)
0.41 (we; average; the scores)
0.83 (images; are resized; such that the shorter side is in {224, 256, 384, 480, 640)
0.88 (the shorter side; is; in {224, 256, 384, 480, 640)

ImageNet Classiﬁcation We evaluate our method on the ImageNet 2012 classiﬁcation dataset [36] that consists of 1000 classes.
0.35 (We; evaluate; our method on the ImageNet 2012 classiﬁcation dataset)
0.14 (that; consists; of 1000 classes)

We also obtain a ﬁnal result on the 100k test images, reported by the test server.
0.45 (We; also obtain; a ﬁnal result on the 100k test images)
0.91 (the 100k test images; reported; by the test server)

We evaluate both top-1 and top-5 error rates.
0.57 (We; evaluate; both top-1 and top-5 error rates)

We ﬁrst evaluate 18-layer and 34-layer plain nets.
0.45 (We; ﬁrst evaluate; 18-layer and 34-layer plain nets)

4 (left) we compare their training/validation errors during the training procedure.
0.31 (we; compare; their training/validation errors; during the training procedure)

We have observed the degradation problem the  Left: the VGG-19 model [41] (19.6 billion FLOPs) as a reference.
0.45 (We; have observed; the degradation problem)

We argue that this optimization difﬁculty is unlikely to be caused by vanishing gradients.
0.90 (this optimization difﬁculty; to be caused; by vanishing gradients)
0.28 (We; argue; that this optimization difﬁculty is unlikely to be caused by vanishing gradients)
0.92 Context(We argue):(this optimization difﬁculty; is; unlikely to be caused by vanishing gradients)

We also verify that the backward propagated gradients exhibit healthy norms with BN.
0.27 (We; verify; that the backward propagated gradients exhibit healthy norms with BN)
0.91 Context(We verify):(the backward propagated gradients; exhibit; healthy norms with BN)

We conjecture that the deep plain nets may have exponentially low convergence rates, which impact the reducing of the training error3.
0.91 (exponentially low convergence rates; impact; the reducing of the training error3)
0.28 (We; conjecture; that the deep plain nets may have exponentially low convergence rates)
0.94 Context(We conjecture):(the deep plain nets; may have; exponentially low convergence rates, which impact the reducing of the training error3)

Next we evaluate 18-layer and 34layer residual nets (ResNets).
0.44 (we; evaluate; 18-layer and 34layer residual nets; T:Next)

4 right), we use identity mapping for all shortcuts and zero-padding for increasing dimensions (option A).
0.57 (we; use; identity mapping; for all shortcuts and zero-padding for increasing dimensions)

We have three major observations from Table 2 and Fig.
0.50 (We; have; three major observations from Table 2 and Fig)

This indicates that the degradation problem is well addressed in this setting and we manage to obtain accuracy gains from increased depth.
0.14 (This; indicates; that the degradation problem is well addressed in this setting and we manage to obtain accuracy gains from increased depth)
0.71 Context(This indicates):(the degradation problem; is well addressed; )
0.40 (we; manage; to obtain accuracy gains from increased depth)
0.40 Context(we manage):(we; manage to obtain; accuracy gains; from increased depth)

VGG-16 is based on our test.
0.88 (VGG-16; is based; on our test)

Last, we also note that the 18-layer plain/residual nets are comparably accurate (Table 2), but the 18-layer ResNet converges faster (Fig.
0.77 (ResNet; converges faster; )
0.27 (we; note; that the 18-layer plain/residual nets are comparably accurate (Table 2), but the 18-layer ResNet converges faster)
0.94 Context(we note):(the 18-layer plain/residual nets; are; comparably accurate (Table 2)

We have shown that  Left: a building block (on 56×56 feature maps) as in Fig.
0.45 (We; have shown; Left)

Next we investigate projection shortcuts (Eqn.(2)).
0.60 (we; investigate; projection shortcuts; T:Next)

In Table 3 we compare three options: (A) zero-padding shortcuts are used for increasing dimensions, and all shortcuts are parameterfree (the same as Table 2 and Fig.
0.60 (we; compare; three options; T:In Table 3)
0.92 (zero-padding shortcuts; are used; for increasing dimensions)
0.77 (all shortcuts; are; parameterfree)

We argue that this is because the zero-padded dimensions in A indeed have no residual learning.
0.94 (the zero-padded dimensions in A; indeed have; no residual learning)
0.28 (We; argue; that this is because the zero-padded dimensions in A indeed have no residual learning)
0.51 Context(We argue):(this; is; because the zero-padded dimensions in A indeed have no residual learning)

C is marginally better than B, and we attribute this to the extra parameters introduced by many (thirteen) projection shortcuts.
0.87 (C; is; marginally better than B)
0.45 (we; attribute; this; to the extra parameters)
0.91 (the extra parameters; introduced; by many (thirteen) projection shortcuts)

So we do not use option C in the rest of this paper, to reduce memory/time complexity and model sizes.
0.39 (we; do not use; option C; L:in the rest of this paper; to reduce memory/time complexity and model sizes)
0.29 Context(we do not use):(we; do not use option C to reduce; memory/time complexity and model sizes)

Next we describe our deeper nets for ImageNet.

Because of concerns on the training time that we can afford, we modify the building block as a bottleneck design4.
0.55 (we; can afford; T:the training time)
0.45 (we; modify; the building block)

For each residual function F, we use a stack of 3 layers instead of 2 (Fig.
0.57 (we; use; a stack of 3 layers instead of 2 (Fig)

50-layer ResNet: We replace each 2-layer block in the 4Deeper non-bottleneck ResNets (e.g., Fig.
0.61 (We; replace; each 2-layer block in the 4Deeper non-bottleneck ResNets (e.g., Fig)

We further note that the degradation problem of plain nets is also witnessed for the bottleneck designs.
0.24 (We; note; that the degradation problem of plain nets is also witnessed for the bottleneck designs)
0.91 Context(We note):(the degradation problem of plain nets; is also witnessed; for the bottleneck designs)

We use option B for increasing dimensions.
0.45 (We; use; option B; for increasing dimensions)

101-layer and 152-layer ResNets: We construct 101layer and 152-layer ResNets by using more 3-layer blocks (Table 1).
0.39 (We; construct; 101layer and 152-layer ResNets)
0.39 Context(We construct):(We; construct 101layer and 152-layer ResNets by using; more 3-layer blocks)

We do not observe the degradation problem and thus enjoy signiﬁcant accuracy gains from considerably increased depth.
0.45 (We; do not observe; the degradation problem)
0.41 (We; enjoy; signiﬁcant accuracy gains from considerably increased depth)

In Table 4 we compare with the previous best single-model results.
0.60 (we; compare; with the previous best single-model results; T:In Table 4)

Our baseline 34-layer ResNets have achieved very competitive accuracy.
0.72 (Our baseline 34-layer ResNets; have achieved; very competitive accuracy)

Our 152-layer ResNet has a single-model top-5 validation error of 4.49%.
0.87 (Our 152-layer ResNet; has; a single-model top-5 validation error of 4.49%)

We combine six models of different depth to form an ensemble (only with two 152-layer ones at the time of submitting).
0.57 (We; combine; six models of different depth to form an ensemble (only with two 152-layer ones at the time of submitting))

We conducted more studies on the CIFAR-10 dataset [20], which consists of 50k training images and 10k testing images in 10 classes.
0.50 (We; conducted; more studies on the CIFAR-10 dataset)
0.93 (the CIFAR-10 dataset; consists; of 50k training images and 10k testing images)

We present experiments trained on the training set and evaluated on the test set.
0.89 (experiments; trained; on the training set)

Our focus is on the behaviors of extremely deep networks, but not on pushing the state-of-the-art results, so we intentionally use simple architectures as follows.

Then we use a stack of 6n layers with 3×3 convolutions on the feature maps of sizes {32, 16, 8} respectively, with 2n layers for each feature map size.
0.22 (we; use respectively; T:Then)

On this dataset we use identity shortcuts in all cases (i.e., option A), Highway [42, 43] Highway [42, 43] 2.5M 2.3M 1.25M 8.80 0.27M 8.75 0.46M 7.51 0.66M 7.17 0.85M 6.97 1.7M 19.4M 7.93 Table 6.
0.60 (we; use; identity shortcuts; L:in all cases; T:On this dataset)

For ResNet-110, we run it 5 times and show “best (mean±std)” as in [43].
0.56 (we; run; it; T:5 times; T:For ResNet-110)
0.44 (we; show; best (mean±std)

so our residual models have exactly the same depth, width, and number of parameters as the plain counterparts.
0.76 (our residual models; have; exactly the same depth, width, and number of parameters as the plain counterparts)

We use a weight decay of 0.0001 and momentum of 0.9, and adopt the weight initialization in [13] and BN [16] but with no dropout.
0.45 (We; use; a weight decay of 0.0001 and momentum of 0.9)
0.41 (We; adopt; the weight initialization; T:in [13)

We start with a learning rate of 0.1, divide it by 10 at 32k and 48k iterations, and terminate training at 64k iterations, which is determined on a 45k/5k train/val split.
0.89 (64k iterations; is determined; L:on a 45k/5k train/val split)
0.20 (We; start; )
0.19 Context(We start):(We; start divide; it; T:by 10; at 32k and 48k iterations)

We follow the simple data augmentation in [24] for training: 4 pixels are padded on each side, and a 32×32 crop is randomly sampled from the padded image or its horizontal ﬂip.
0.85 (a 32×32 crop; is randomly sampled; from the padded image or its horizontal ﬂip)
0.88 (4 pixels; are; padded on each side)
0.51 Context(4 pixels are):(We; follow; the simple data augmentation in [24] for training)

For testing, we only evaluate the single view of the original 32×32 image.
0.45 (we; only evaluate; the single view of the original 32×32 image)

We compare n = {3, 5, 7, 9}, leading to 20, 32, 44, and 56-layer networks.
0.19 (We; compare n; )

4, right), our ResNets manage to overcome the optimization difﬁculty and demonstrate accuracy gains when the depth increases.
0.73 (the depth; increases; )
0.59 (our ResNets; manage; to overcome the optimization difﬁculty and demonstrate accuracy gains)
0.59 Context(our ResNets manage):(our ResNets; manage to overcome; the optimization difﬁculty)
0.48 Context(our ResNets manage):(our ResNets; manage to demonstrate; accuracy gains; T:when the depth increases)

We further explore n = 18 that leads to a 110-layer ResNet.
0.33 (We; explore; n = 18 that leads to a 110-layer ResNet)
0.60 (n = 18; leads; to a 110-layer ResNet)

In this case, we ﬁnd that the initial learning rate of 0.1 is slightly too large to start converging5.
0.92 (the initial learning rate of 0.1; to start; converging5)
0.47 (we; ﬁnd; that the initial learning rate of 0.1 is slightly too large to start converging5; L:In this case)
0.93 Context(we ﬁnd):(the initial learning rate of 0.1; is; slightly too large to start converging5)

So we use 0.01 to warm up the training until the training error is below 80% (about 400 iterations), and then go back to 0.1 and continue training.
0.93 (the training error; is; below 80%)
0.37 (we; go; back to 0.1; T:then)
0.41 (we; continue; training)
0.50 (we; use; 0.01; to warm up the training until the training error is below 80% (about 400 iterations))
0.39 Context(we use):(we; use 0.01 to warm up; the training; T:until the training error is below 80%)

We argue that this is because of overﬁtting.
0.19 (We; argue; that this is because of overﬁtting)
0.40 Context(We argue):(this; is; because of overﬁtting)

In this paper, we use no maxout/dropout and just simply impose regularization via deep and thin architectures by design, without distracting from the focus on the difﬁculties of optimization.
0.60 (we; use; no maxout/dropout; L:In this paper)
0.41 (we; just simply impose; regularization)

But combining with stronger regularization may improve results, which we will study in the future.
0.86 (combining with stronger regularization; may improve; results, which we will study in the future)
0.88 (results; will study; T:in the future)

Object Detection on PASCAL and MS COCO Our method has good generalization performance on other recognition tasks.
0.70 (Our method; has; good generalization performance on other recognition tasks)

We adopt Faster R-CNN [32] as the detection method.
0.50 (We; adopt; Faster R-CNN; as the detection method)

Here we are interested in the improvements of replacing VGG-16 [41] with ResNet-101.
0.74 (we; are; interested in the improvements of replacing VGG-16 [41] with ResNet-101; L:Here)

Most remarkably, on the challenging COCO dataset we obtain a 6.0% increase in COCO’s standard metric (mAP@[.5, .95]), which is a 28% relative improvement.
0.94 (Most remarkably, on the challenging COCO dataset we obtain a 6.0% increase in COCO's standard metric (mAP@[.5, .95; is; a 28% relative improvement)
0.92 (the challenging COCO; dataset; we obtain a 6.0% increase in COCO's standard metric (mAP@[.5, .95)
0.56 Context(the challenging COCO dataset):(we; obtain; a 6.0% increase in COCO's standard metric (mAP@[.5, .95)

Based on deep residual nets, we won the 1st places in several tracks in ILSVRC & COCO 2015 competitions: ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation.
0.68 (we; won; the 1st places in several tracks in ILSVRC & COCO 2015 competitions)

These results support our basic motivation (Sec.3.1) that the residual functions might be generally closer to zero than the non-residual functions.
0.75 (These results; support; our basic motivation (Sec.3.1) that the residual functions might be generally closer to zero than the non-residual functions)
0.91 (the residual functions; might be; generally closer to zero than the non-residual functions)

We also notice that the deeper ResNet has smaller magnitudes of responses, as evidenced by the comparisons among ResNet-20, 56, and 110 in Fig.
0.22 (We; also notice; that the deeper ResNet has smaller magnitudes of responses)
0.93 Context(We also notice):(the deeper ResNet; has; smaller magnitudes of responses)

We explore an aggressively deep model of over 1000 layers.
0.45 (We; explore; an aggressively deep model of over 1000 layers)

We set n = 200 that leads to a 1202-layer network, which is trained as described above.
0.79 (a 1202-layer network; is trained; T:as described above)
0.24 (We; set; n = 200)

Our method shows no optimization difﬁculty, and this 103-layer network is able to achieve training error <0.1% (Fig.
0.70 (Our method; shows; no optimization difﬁculty)
0.94 (this 103-layer network; is; able to achieve training error <)
0.91 (this 103-layer network; to achieve; training error; T:<)

The testing result of this 1202-layer network is worse than that of our 110-layer network, although both 0123456051020iter.
0.83 (The testing result of this 1202-layer network; is; worse than that of our 110-layer network)

Fully convolutional networks In this section we introduce our detection method based on the baseline Faster R-CNN [32] system.
0.31 (we; introduce; our detection method)

We have experimented with ResNet-50/101 at the time of the ILSVRC & COCO 2015 detection competitions.
0.61 (We; have experimented; with ResNet-50/101; T:at the time of the ILSVRC & COCO 2015 detection competitions)

Unlike VGG-16 used in [32], our ResNet has no hidden fc layers.
0.83 (VGG-16; used; T:in [32)
0.76 (our ResNet; has; no hidden fc layers)

We adopt the idea of “Networks on Conv feature maps” (NoC) [33] to address this issue.
0.61 (We; adopt; the idea of "Networks on Conv feature maps" (NoC) [33)

We compute the full-image shared conv feature maps using those layers whose strides on the image are no greater than 16 pixels (i.e., conv1, conv2 x, conv3 x, and conv4 x, totally 91 conv layers in ResNet-101; Table 1).
0.33 (We; compute; the full-image shared conv feature maps using those layers)
0.92 (the full-image shared conv feature maps; using; those layers whose strides on the image are no greater than 16 pixels (i.e., conv1, conv2 x, conv3 x, and conv4 x, totally 91 conv layers in ResNet-101; Table 1))
0.89 (those layers; are; no greater than 16 pixels)

We consider these layers as analogous to the 13 conv layers in VGG-16, and by doing so, both ResNet and VGG-16 have conv feature maps of the same total stride (16 pixels).
0.45 (We; consider; these layers)
0.95 (both ResNet and VGG-16; have conv; feature maps of the same total stride)

For the usage of BN layers, after pre-training, we compute the BN statistics (means and variances) for each layer on the ImageNet training set.
0.64 (we; compute; the BN statistics; for each layer on the ImageNet training set; T:after pre-training)

We ﬁx the BN layers mainly for reducing memory consumption in Faster R-CNN training.
0.68 (We; ﬁx; the BN layers; mainly for reducing memory consumption in Faster R-CNN training)

PASCAL VOC Following [7, 32], for the PASCAL VOC 2007 test set, we use the 5k trainval images in VOC 2007 and 16k trainval images in VOC 2012 for training (“07+12”).
0.74 (we; use; the 5k trainval images in VOC 2007 and 16k trainval images in VOC 2012; for training; T:Following [7, 32; T:for the PASCAL VOC 2007 test set)

For the PASCAL VOC 2012 test set, we use the 10k trainval+test images in VOC 2007 and 16k trainval images in VOC 2012 for training (“07++12”).
0.61 (we; use; the 10k trainval+test images in VOC 2007 and 16k trainval images in VOC 2012; for training)

We evaluate the PASCAL VOC metric (mAP @ IoU = 0.5) and the standard COCO metric (mAP @ IoU = .5:.05:.95).
0.19 (We; evaluate; )

We use the 80k images on the train set for training and the 40k images on the val set for evaluation.
0.45 (We; use; the 80k images on the train)
0.93 (the train; set; for training and the 40k images on the val)
0.93 (the val; set; for evaluation)

Our detection system for COCO is similar to that for PASCAL VOC.
0.35 (Our detection system for COCO; is; similar to that)

We train the COCO models with an 8-GPU implementation, and thus the RPN step has a mini-batch size of 8 images (i.e., 1 per GPU) and the Fast R-CNN step has a mini-batch size of 16 images.
0.50 (We; train; the COCO models; with an 8-GPU implementation)
0.95 (the RPN step; has; a mini-batch size of 8 images)
0.96 (the Fast R-CNN step; has; a mini-batch size of 16 images)

For completeness, we report the improvements made for the competitions.
0.60 (we; report; the improvements made for the competitions; T:For completeness)
0.90 (the improvements; made; for the competitions)

Our box reﬁnement partially follows the iterative localization in [6].
0.66 (Our box reﬁnement; partially follows; the iterative localization in [6)

So for inference, we pool a new feature from the regressed box and obtain a new classiﬁcation score and a new regressed box.
0.45 (we; pool; a new feature from the regressed box)
0.41 (we; obtain; a new classiﬁcation score and a new regressed box)

We combine these 300 new predictions with the original 300 predictions.
0.45 (We; combine; these 300 new predictions; with the original 300 predictions)

We combine global context in the Fast R-CNN step.
0.50 (We; combine; global context in the Fast R-CNN step)

Given the full-image conv feature map, we pool a feature by global Spatial Pyramid Pooling [12] (with a “single-level” pyramid) which can be implemented as “RoI” pooling using the entire image’s bounding box as the RoI.
0.61 (we; pool; a feature by global Spatial Pyramid Pooling [12] (with a "single-level" pyramid)
0.99 (a feature by global Spatial Pyramid Pooling [12] (with a "single-level" pyramid; can be implemented; as "RoI)
0.74 (RoI; pooling; )

In our current implementation, we have performed multi-scale testing following [33]; we have not performed multi-scale training because of limited time.
0.73 (multi-scale testing; following; )
0.39 (we; have not performed; multi-scale training; because of limited time)
0.38 Context(we have not performed):(we; have performed; multi-scale testing following; L:In our current implementation)

In addition, we have performed multi-scale testing only for the Fast R-CNN step (but not yet for the RPN step).
0.50 (we; have performed; multi-scale testing; only for the Fast R-CNN step; T:not yet; for the RPN step)

With a trained model, we compute conv feature maps on an image pyramid, where the image’s shorter sides are s ∈ {200, 400, 600, 800, 1000}.
0.45 (we; compute; conv feature maps on an image pyramid)

We select two adjacent scales from the pyramid following [33].
0.45 (We; select; two adjacent scales from the pyramid following)
0.80 (two adjacent scales from the pyramid; following; )

Next we use the 80k+40k trainval set for training and the 20k test-dev set for evaluation.
0.70 (we; use; the 80k+40k trainval set for training and the 20k test-dev set for evaluation; L:Next)
0.97 (the 80k+40k trainval set for training and the 20k test-dev; set; for evaluation)

This is our single-model result.
0.31 (This; is; our single-model result)

We use an ensemble for proposing regions, and the union set of proposals are processed by an ensemble of per-region classiﬁers.
0.45 (We; use; an ensemble for proposing regions)
0.93 (the union set of proposals; are processed; by an ensemble of per-region classiﬁers)

Table 9 shows our result based on an ensemble of 3 networks.
0.49 (Table 9; shows; our result)

We revisit the PASCAL VOC dataset based on the above model.
0.50 (We; revisit; the PASCAL VOC dataset)
0.89 (the PASCAL VOC dataset; based; on the above model)

With the single model on the COCO dataset (55.7% mAP@.5 in Table 9), we ﬁne-tune this model on the PASCAL VOC sets.
0.84 (With the single model on the COCO dataset (55.7% mAP@.5 in Table 9), we ﬁne-tune this model on the PASCAL VOC; sets; )

By doing so GoogLeNet [44] (ILSVRC’14) our single model (ILSVRC’15) our ensemble (ILSVRC’15) Table 12.

Our results (mAP, %) on the ImageNet detection dataset.
0.37 (Our results; mAP; )

Our detection system is Faster R-CNN [32] with the improvements in Table 9, using ResNet-101.
0.83 (Our detection system; is; Faster R-CNN [32] with the improvements in Table 9)

we achieve 85.6% mAP on PASCAL VOC 2007 (Table 10) and 83.8% on PASCAL VOC 2012 (Table 11)6.
0.50 (we; achieve; 85.6% mAP; L:on PASCAL VOC 2007)

Our object detection algorithm for ImageNet DET is the same as that for MS COCO in Table 9.
0.65 (Our object detection algorithm for ImageNet DET; is; the same as that for MS COCO in Table 9)

We split the validation set into two parts (val1/val2) following [8].
0.64 (We; split; the validation set into two parts (val1/val2); T:following [8)
0.93 (the validation; set; into two parts; T:following [8)

We ﬁne-tune the detection models using the DET training set and the val1 set.
0.51 (We; ﬁne tune; the detection models using the DET training set and the val1 set)

We do not use other ILSVRC 2015 data.
0.50 (We; do not use; other ILSVRC 2015 data)

Our single model with ResNet-101 has top-5 LOC error on predicted CLS LOC error on GT CLS 33.1 [41] 1-crop ResNet-101 1-crop ResNet-101 dense ResNet-101 dense RPN+RCNN ResNet-101 dense RPN+RCNN ensemble dense Table 13.
0.79 (dense RPN+RCNN ResNet-101 dense RPN+RCNN; ensemble; dense Table 13)

58.8% mAP and our ensemble of 3 models has 62.1% mAP on the DET test set (Table 12).
0.85 (58.8% mAP and our ensemble of 3 models; has; 62.1% mAP on the DET test set)

Following [40, 41], we assume that the image-level classiﬁers are ﬁrst adopted for predicting the class labels of an image, and the localization algorithm only accounts for predicting bounding boxes based on the predicted classes.
0.40 (we; assume; that the image-level classiﬁers are ﬁrst adopted for predicting the class labels of an image, and the localization algorithm only accounts for predicting bounding boxes based on the predicted classes; T:Following [40, 41)
0.94 Context(we assume):(the image-level classiﬁers; are ﬁrst; adopted for predicting the class labels of an image, and the localization algorithm only accounts for predicting bounding boxes based on the predicted classes)
0.94 (the image-level classiﬁers; adopted; for predicting the class labels of an image, and the localization algorithm only accounts for predicting bounding boxes based on the predicted classes)

We adopt the “per-class regression” (PCR) strategy [40, 41], learning a bounding box regressor for each class.
0.50 (We; adopt; the "per-class regression" (PCR) strategy; learning a bounding box regressor for each class)
0.29 Context(We adopt):(We; adopt the "per-class regression" (PCR) strategy learning; a bounding box regressor for each class)

We pre-train the networks for ImageNet classiﬁcation and then ﬁne-tune them for localization.
0.50 (We; pre-train; the networks for ImageNet classiﬁcation)
0.40 (We; tune; them; for localization; T:then)

We train networks on the provided 1000-class ImageNet training set.
0.61 (We; train; networks on the provided 1000-class ImageNet training set)

Our localization algorithm is based on the RPN framework of [32] with a few modiﬁcations.
0.70 (Our localization algorithm; is based; on the RPN framework of [32)

Unlike the way in [32] that is category-agnostic, our RPN for localization is designed in a per-class form.
0.17 (that; is; category-agnostic)
0.46 (our RPN for localization; is designed; )

As in [32], our bounding box regression is with reference to multiple translation-invariant “anchor” boxes at each position.
0.74 (our bounding box regression; is; with reference to multiple translation-invariant "anchor)

As in our ImageNet classiﬁcation training (Sec.

3.4), we randomly sample 224×224 crops for data augmentation.
0.45 (we; randomly sample; 224×224 crops; for data augmentation)

We use a mini-batch size of 256 images for ﬁne-tuning.
0.57 (We; use; a mini-batch size of 256 images for ﬁne-tuning)

Following [41], we ﬁrst perform “oracle” testing using the ground truth class as the classiﬁcation prediction.
0.66 (we; ﬁrst perform; oracle" testing using the ground truth class as the classiﬁcation prediction; T:Following [41)

Under the same setting, our RPN method using ResNet-101 net signiﬁcantly reduces the center-crop error to 13.3%.
0.75 (our RPN method; reduces; the center-crop error; to 13.3%; L:Under the same setting)
0.41 Context(our RPN method reduces):(our RPN method; reduces the center-crop error using; net)

This comparison demonstrates the excellent performance of our framework.
0.83 (This comparison; demonstrates; the excellent performance of our framework)

With dense (fully convolutional) and multi-scale testing, our ResNet-101 has an error of 11.7% using ground truth classes.
0.79 (our ResNet-101; has; an error of 11.7% using ground truth classes)
0.90 (11.7%; using; ground truth classes)

But we notice that on this dataset, one image usually contains a single dominate object, and the proposal regions highly overlap with each other and thus have very similar RoI-pooled features.
0.78 (the proposal regions; highly overlap; with each other)
0.31 (we; notice; that on this dataset, one image usually contains a single dominate object, and the proposal regions highly overlap with each other and thus have very similar RoI-pooled features)
0.92 Context(we notice):(one image; contains; a single dominate object; T:on this dataset; T:usually)

Motivated by this, in our current experiment we use the original RCNN [8] that is RoI-centric, in place of Fast R-CNN.
0.36 (we; use; the original RCNN [8] that is RoI-centric, in place of Fast R-CNN; L:in our current experiment)
0.80 (the original RCNN; is; RoI-centric)

Our R-CNN implementation is as follows.
0.60 (Our R-CNN implementation; is; as follows)

We apply the per-class RPN trained as above on the training images to predict bounding boxes for the ground truth class.
0.57 (We; apply; the per-class RPN trained as above on the training images to predict bounding boxes for the ground truth class)
0.93 (the per-class RPN; trained; as above; to predict bounding boxes for the ground truth class)

This is our single-model result on the validation set.
0.31 (This; is; our single-model result on the validation set)

Using an ensemble of networks for both classiﬁcation and localization, we achieve a top-5 localization error of 9.0% on the test set
0.39 (we; achieve; a top-5 localization error of 9.0%; T:on the test set)

